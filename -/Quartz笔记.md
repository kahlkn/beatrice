当任务的触发器触发以后，调度器的一个工作线程将会调用 Execute(..) 方法。传递到这个方法的 JobExecutionContext 对象提供了一个任务实例，这个实例包含以下运行时环境：一个运行当前任务的调度器的句柄，触发当前任务的触发器的句柄，当前任务的 JobDetail 对象，以及其他几个对象。

调度器加载任务后 Quartz.NET 的客户端 (即我们的应用程序) 会创建 JobDetail 对象。这个对象包含了任务的各种属性设置，以及一个 JobDataMap——它可以用来存储指定任务类型的状态信息。JobDetail 是任务对象的本质，我们会在下一节更详细地讨论它。

触发器用来触发 (或者叫“点火”) 任务的执行操作。当你想要调度一个任务的时候，你需要初始化一个触发器并按照你想要的调度计划来调整它的属性。触发器也可能有一个关联的 JobDataMap，这对于向触发器触发操作指定的任务传递参数来说很有用。Quartz 附带了一些不同的触发器类型，但是通常情况下用的最多的是SimpleTrigger(接口是ISimpleTrigger) 以及 CronTrigger(接口是ICronTrigger)。

如果你需要在指定时间点仅执行一次，或者在指定时间内重复多次并且在每执行前延迟特定时间的任务，使用SimpleTrigger将会很方便。如果你想让触发器有类似于日历的调度计划，CronTrigger将会很合适，例如“每周五下午”或者“每个月第10天的10:15”。

为什么要有任务和触发器？很多任务调试工具都没有将触发器和任务的概念分离。一些组件简单地将任务当作附带一点任务标识的执行时间(或者计划)。还有一些组件很像是Quartz的任务和触发器的结合。但是当我们开发Quartz时， 我们决定将调度计划和在调度计划内将要执行的操作分离开。在我们看来这样做有很多好处。

例如：任务可以独立于触发器创建并存储到任务调度器中，并且可以将多个触发器关联到同一个任务上。另一个松耦合的好处是对于调度器中保留的任务，当与之关联的触发器过期之后，可以不用重新定义这个任务就对它再次进行调度安排；同样的你也可以修改或替换一个触发器而不用重新定义与它关联的任务。






