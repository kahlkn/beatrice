- Title: Java 中锁的介绍
- Category:
- Tag: Java
- Author: Kahle
- Creation Time: 2018-10-19T12:52:30.666+0800
- Update Time: 2018-10-19T12:52:30.666+0800
- Original:
- Reference:
    - [Java 中的锁分类](https://www.cnblogs.com/qifengshi/p/6831055.html)
    - [一分钟教你知道乐观锁和悲观锁的区别](https://www.cnblogs.com/goody9807/p/6512468.html)

---


### 导语

现在锁的概念越来越多，有点理不清了。最初锁的出现是为了安全的解决多线程竞争共享资源的问题，但是由于最初的锁的设计是非常重量级的，尽管解决了问题，但是性能相差太多了。从此开始就有了各种各样的锁的出现，也因为应用场景的不同，也出现了不同场景下使用的锁。


### 正文

#### **>> 公平锁/非公平锁**

**公平锁**指多个线程按照申请锁的顺序来获取锁。

**非公平锁**指多个线程获取锁的顺序并不是按照申请锁的顺序，是通过锁竞争来获取的，可能会出现优先级反转或者饥饿现象（ReentrantLock 默认为非公平锁，可以通过构造设置为公平锁，Synchronized 也是非公平锁）。


#### **>> 可重入锁**

**可重入锁**指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁（即同个线程下多个有锁方法自动获取锁，否则可能死锁）。


#### **>> 独享锁/共享锁**

**独享锁**指该锁一次只能被一个线程所持有（Synchronized、ReentrantLock 和 ReadWriteLock 中的 写锁）。

**共享锁**指该锁可被多个线程所持有（ReadWriteLock 中的 读锁）。


#### **>> 乐观锁/悲观锁**

**乐观锁**对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

**悲观锁**对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。

**乐观锁**在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

**悲观锁**在Java中的使用，就是利用各种锁。


#### **>> 分段锁**

**分段锁**是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。


#### **>> 偏向锁/轻量级锁/重量级锁**

**偏向锁**指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

**轻量级锁**指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁**指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。


#### **>> 自旋锁**

**自旋锁**指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。


#### **>> 总结**

**Synchronized**为非公平锁，不能变成公平锁，是可重入锁 和 互斥锁。**ReentrantLock**可通过构造函数指定该锁是否是公平锁，默认是非公平锁，是可重入锁 和 互斥锁。**ReadWriteLock**可通过构造函数指定该锁是否是公平锁，默认是非公平锁（不确定），是可重入锁（不确定） 并且 读锁是共享锁，写锁是互斥锁。


